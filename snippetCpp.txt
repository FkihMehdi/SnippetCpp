//prepare snippets for c++
{
	"solve": {
		"prefix": "solve",
		"body": [
			"#include <bits/stdc++.h>",
			"#define int long long",
			"#define ld long double",
			"#define pb push_back",
			"#define mp make_pair",
			"#define pii pair<int,int>",
			"#define pll pair<ll,ll>",
			"#define vi vector<int>",
			"#define vll vector<ll>",
			"#define vvi vector<vi>",
			"#define vvl vector<vll>",
			"#define vpii vector<pii>",
			"#define vpll vector<pll>",
			"#define rep(i,a,b) for(int i=a;i<b;i++)",
			"#define all(a) a.begin(),a.end()",
			"#define fi first",
			"#define se second",
			"#define sz(a) (int)(a.size())",
			"#define ms(s,val) memset(s,val,sizeof(s))",
			"#define inf 1000000000",
			"#define mod 1000000007",
			"#define pi 3.14159265358979323846",
			"#define repd(i,a,b) for(int i=a;i>=b;i--)",
			"#define endl '\\n'",
			"#define bits(x) __builtin_popcount(x)",
			"#define len(a) ((int)(a).size())",
			"using namespace std;",
			"void yes(){cout<<\"YES\\n\";}",
			"void no(){cout<<\"NO\\n\";}",
			"void solve(){",
			"",
			"}",
			"int32_t main(){",
			"ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);",
			"#ifndef ONLINE_JUDGE",
			"freopen(\"input.txt\",\"r\",stdin);",
			"freopen(\"output.txt\",\"w\",stdout);",
			"#endif",
			"int t;cin>>t;",
			"while(t--){",
			"     solve();",
			"}",
			"return 0;",
			"}",
		],
		"description": "solve"
	},
	"diophantine": {
		"prefix": "diophantine",
		"body": [
			"ll gcd(ll a,ll b,ll &x,ll &y){",
			"if(b==0){",
			"x=1,y=0;",
			"return a;",
			"}",
			"ll x1,y1;",
			"ll g=gcd(b,a%b,x1,y1);",
			"x=y1,y=x1-(a/b)*y1;",
			"return g;",
			"}",
			"bool find_any_solution(ll a,ll b,ll c,ll &x0,ll &y0,ll &g){",
			"g=gcd(abs(a),abs(b),x0,y0);",
			"if(c%g){",
			"return false;",
			"}",
			"x0*=c/g,y0*=c/g;",
			"if(a<0)x0=-x0;",
			"if(b<0)y0=-y0;",
			"return true;",
			"}",
		]
	},
	"totientloglog": {
		"prefix": "totientloglog",
		"body": [
			"// phi in O(nloglogn)",
			"const int N = 1e6 + 5;",
			"ll phi[N + 2];",
			"void computeTotient()",
			"{",
			"for (int i = 0; i <= N; i++)",
			"    phi[i] = i;",
			"for (int i = 2; i <= N; i++)",
			"{",
			"    if (phi[i] == i)",
			"    {",
			"     for (int j = i; j <= N; j += i)",
			"      phi[j] -= phi[j] / i;",
			"}",
			"}",
			"}",
		]
	},
	"totientsqrt": {
		"prefix": "totientsqrt",
		"body": [
			"// phi in O(sqrt(n))",
			"ll phi(ll n)",
			"{",
			"ll result = n;",
			"for (ll p = 2; p * p <= n; ++p) {",
			"if (n % p == 0) {",
			"while (n % p == 0)",
			"n /= p;",
			"result -= result / p;",
			"}",
			"}",
			"if (n > 1)",
			"result -= result / n;",
			"return result;",
			"}",
		]
	},
	"seive": {
		"prefix": "seive",
		"body": [
			"const int N = 1e6 + 5;",
			"vector<int> prime(N+2,1);",
			"void seive()",
			"{",
			"prime[0] = prime[1] = 1;",
			"for (int i = 2; i <= N; i++)",
			"{",
			"if (prime[i] == 1)",
			"{",
			"for (int j = i; j <= N; j += i)",
			"if(prime[j] == 1)",
			"prime[j] = i;",
			"}",
			"}",
			"}",
		]
	},
	"inverse": {
		"prefix": "inverse",
		"body": [
			"// inverse modulo",
			"ll gcd(ll a, ll b, ll &x, ll &y)",
			"{",
			"if (b == 0)",
			"{",
			"x = 1, y = 0;",
			"return a;",
			"}",
			"ll x1, y1;",
			"ll g = gcd(b, a % b, x1, y1);",
			"x = y1;",
			"y = x1 - (a / b) * y1;",
			"return g;",
			"}",
			"ll inverse(ll a, ll m)",
			"{",
			"ll x, y;",
			"ll g = gcd(a, m, x, y);",
			"if (g != 1)",
			"return -1;",
			"else",
			"{",
			"x = (x % m + m) % m;",
			"return x;",
			"}",
			"}",
		]
	},
	"chiense": {
		"prefix": "chiense",
		"body": [
			"//chieense remainder theorem",
			"struct Congruence",
			"{",
			"ll a, n;",
			"};",
			"ll chinese_remainder(vector<Congruence> &congruences)",
			"{",
			"ll prod = 1;",
			"for (auto &c : congruences)",
			"prod *= c.n;",
			"ll result = 0;",
			"for (auto &c : congruences)",
			"{",
			"ll m = prod / c.n;",
			"ll mi = inverse(m, c.n);",
			"result = (result + c.a * m * mi) % prod;",
			"}",
			"return result;",
			"}",
		]
	},
	"numberofdivisor": {
		"prefix": "numberofdivisor",
		"body": [
			"// number of divisor",
			"ll number_of_divisor(ll n)",
			"{",
			"ll result = 1;",
			"for (ll p = 2; p * p <= n; ++p)",
			"{",
			"ll cnt = 0;",
			"while (n % p == 0)",
			"{",
			"n /= p;",
			"cnt++;",
			"}",
			"result *= (cnt + 1);",
			"}",
			"if (n > 1)",
			"result *= 2;",
			"return result;",
			"}",
		]
	},
	"sumrofdivisor": {
		"prefix": "sumrofdivisor",
		"body": [
			"ll power(ll a, ll b)",
			"{",
			"ll result = 1;",
			"while (b > 0)",
			"{",
			"if (b & 1)",
			"result = result * a;",
			"a = a * a;",
			"b >>= 1;",
			"}",
			"return result;",
			"}",
			"// sum of divisor",
			"ll sum_of_divisor(ll n)",
			"{",
			"ll result = 1;",
			"for (ll p = 2; p * p <= n; ++p)",
			"{",
			"ll cnt = 0;",
			"while (n % p == 0)",
			"{",
			"n /= p;",
			"cnt++;",
			"}",
			"result *= ((power(p, cnt + 1) - 1) / (p - 1));",
			"}",
			"if (n > 1)",
			"result *= (n+1);",
			"return result;",
			"}",
		]
	},
	"power": {
		"prefix": "power",
		"body": [
			"ll power(ll a, ll b)",
			"{",
			"ll result = 1;",
			"while (b > 0)",
			"{",
			"if (b & 1)",
			"result = (result * a) % mod;",
			"a = (a * a) % mod;",
			"b >>= 1;",
			"}",
			"return result;",
			"}",
		]
	},
	"nCr": {
		"prefix": "nCr",
		"body": [
			"ll fact[N], invfact[N];",
			"void precompute()",
			"{",
			"fact[0] = 1;",
			"for (int i = 1; i < N; i++)",
			"fact[i] = (fact[i - 1] * i) % mod;",
			"invfact[N - 1] = power(fact[N - 1], mod - 2);",
			"for (int i = N - 2; i >= 0; i--)",
			"invfact[i] = (invfact[i + 1] * (i + 1)) % mod;",
			"}",
			"ll nCr(ll n, ll r)",
			"{",
			"if (r > n)",
			"return 0;",
			"ll ans = (fact[n] * invfact[r]) % mod;",
			"ans = (ans * invfact[n - r]) % mod;",
			"return ans;",
			"}",
		]
	},
	"Mobius": {
		"prefix": "Mobius",
		"body": [
			"// mobius function",
			"const int N = 1e6 + 5;",
			"vector<int> mobius(N + 2, 1);",
			"void Mobius()",
			"{",
			"for(int i = 1; i <= N; i++){",
			"if (i == 1) mobius[i] = 1;",
			"else{",
			"if (prime[i/prime[i]] == prime[i]) mobius[i] = 0;",
			"else mobius[i] = -mobius[i/prime[i]];",
			"}",
			"}",
			"}",
		]
	},
	"largestsubsequence": {
		"prefix": "largestsubsequence",
		"body": [
			"map<int, int> mp;",
			"for (int i = 0; i < n; i++)",
			"{",
			"j = max(mp[a[i]], j);",
			"ans = max(ans, i - j + 1);",
			"mp[a[i]] = i + 1;",
			"}",
			"cout << ans << endl;"
		]
	},
	"bfs": {
		"prefix": "bfs",
		"body": [
			"void bfs(int src, vector<int> adj[], vector<int> &dist)",
			"{",
			"queue<int> q;",
			"q.push(src);",
			"dist[src] = 0;",
			"while (!q.empty())",
			"{",
			"int node = q.front();",
			"q.pop();",
			"for (auto it : adj[node])",
			"{",
			"if (dist[it] == -1)",
			"{",
			"dist[it] = dist[node] + 1;",
			"q.push(it);",
			"}",
			"}",
			"}",
			"}"
		]
	},
	"dfs": {
		"prefix": "dfs",
		"body": [
			"void dfs(int node, vector<int> adj[], vector<int> &vis)",
			"{",
			"vis[node] = 1;",
			"for (auto it : adj[node])",
			"{",
			"if (!vis[it])",
			"dfs(it, adj, vis);",
			"}",
			"}"
		]
	},
	"alldivisor": {
		"prefix": "alldivisor",
		"body": [
			"vector<int> res;",
			"for (int i = 1; i * i <= n; i++)",
			"{",
			"if (n % i == 0)",
			"{",
			"res.push_back(i);",
			"if (i != n / i)",
			"res.push_back(n / i);",
			"}",
			"}",
		]
	},
	"trie": {
		"prefix": "trie",
		"body": [
			"class Node",
			"{",
			"public:",
			"    char s;",
			"    unordered_map<char, Node *> children;",
			"    string word;",
			"    bool isTerminal;",
			"    Node(char s)",
			"    {",
			"        this->s = s;",
			"        this->isTerminal = false;",
			"        word = \"\";",
			"    }",
			"};",
			"",
			"class Trie",
			"{",
			"public:",
			"    Node *root;",
			"    Trie()",
			"    {",
			"        root = new Node('\\0');",
			"    }",
			"    void addWord(string word)",
			"    {",
			"        Node *temp = root;",
			"        for (auto ch : word)",
			"        {",
			"            if (temp->children.find(ch) == 0)",
			"            {",
			"                temp->children[ch] = new Node(ch);",
			"            }",
			"            temp = temp->children[ch];",
			"        }",
			"        temp->isTerminal = true;",
			"        temp->word = word;",
			"    }",
			"};"
		]
	},
	"Geo": {
		"prefix": "geo",
		"body": [
			"const double EPS = 1e-9;",
			"",
			"//pick's theorem : S = I + B/2 - 1",
			"//S : surface of polygon , I : number of points inside polygon without the boundry , B the number of points int the boundry of the polygon",
			"// point operations",
			"//change sometimes the type to int",
			"struct point2d",
			"{",
			"    double x, y;",
			"    point2d() {}",
			"    point2d(double x, double y) : x(x), y(y) {}",
			"    point2d &operator+=(const point2d &t)",
			"    {",
			"        x += t.x;",
			"        y += t.y;",
			"        return *this;",
			"    }",
			"    point2d &operator-=(const point2d &t)",
			"    {",
			"        x -= t.x;",
			"        y -= t.y;",
			"        return *this;",
			"    }",
			"    point2d &operator*=(double t)",
			"    {",
			"        x *= t;",
			"        y *= t;",
			"        return *this;",
			"    }",
			"    point2d &operator/=(double t)",
			"    {",
			"        x /= t;",
			"        y /= t;",
			"        return *this;",
			"    }",
			"    point2d operator+(const point2d &t) const",
			"    {",
			"        return point2d(*this) += t;",
			"    }",
			"    point2d operator-(const point2d &t) const",
			"    {",
			"        return point2d(*this) -= t;",
			"    }",
			"    point2d operator*(double t) const",
			"    {",
			"        return point2d(*this) *= t;",
			"    }",
			"    point2d operator/(double t) const",
			"    {",
			"        return point2d(*this) /= t;",
			"    }",
			"    double cross(const point2d &t) const",
			"    {",
			"        return x * t.y - y * t.x;",
			"    }",
			"    double dot(const point2d &t) const",
			"    {",
			"        return x * t.x + y * t.y;",
			"    }",
			"    double cross(const point2d &a, const point2d &b) const",
			"    {",
			"        return (a - *this).cross(b - *this);",
			"    }",
			"    double norm() const",
			"    {",
			"        return x * x + y * y;",
			"    }",
			"    double abs() const",
			"    {",
			"        return sqrt(norm());",
			"    }",
			"    double proj(const point2d &t) const",
			"    {",
			"        return dot(t) / t.abs();",
			"    }",
			"    double angle(const point2d &t) const",
			"    {",
			"        return acos(dot(t) / abs() / t.abs());",
			"    }",
			"    double det(const point2d &t) const",
			"    {",
			"        return x * t.y - y * t.x;",
			"    }",
			"};",
			"",
			"struct line",
			"{",
			"    double a, b, c;",
			"    line() {}",
			"    line(point2d p, point2d q)",
			"    {",
			"        a = p.y - q.y;",
			"        b = q.x - p.x;",
			"        c = -a * p.x - b * p.y;",
			"        norm();",
			"    }",
			"",
			"    void norm()",
			"    {",
			"        double z = sqrt(a * a + b * b);",
			"        if (abs(z) > EPS)",
			"        {",
			"            a /= z, b /= z, c /= z;",
			"        }",
			"    }",
			"",
			"    double dist(point2d p) const",
			"    {",
			"        return a * p.x + b * p.y + c;",
			"    }",
			"};",
			"",
			"point2d operator*(double a, point2d b)",
			"{",
			"    return b * a;",
			"}",
			"",
			"// line operations",
			"",
			"bool intersect(line m, line n, point2d &res)",
			"{",
			"    point2d p(m.a, m.b), q(n.a, n.b);",
			"    double d = p.det(q);",
			"    if (abs(d) < EPS)",
			"    {",
			"        return false;",
			"    }",
			"    point2d a(m.c, m.b), b(n.c, n.b), c(m.a, m.c), e(n.a, n.c);",
			"    res.x = -a.det(b) / d;",
			"    res.y = -c.det(e) / d;",
			"    return true;",
			"}",
			"",
			"bool parallel(line m, line n)",
			"{",
			"    point2d p(m.a, m.b), q(n.a, n.b);",
			"    // return abs(det(p, q)) < EPS;",
			"    return abs(p.det(q)) < EPS;",
			"}",
			"",
			"bool equivalent(line m, line n)",
			"{",
			"    point2d p(m.a, m.b), q(n.a, n.b), r(m.a, m.c), s(n.a, n.c), t(m.b, m.c), u(n.b, n.c);",
			"    // return abs(det(p, q)) < EPS && abs(det(r, s)) < EPS && abs(det(t, u)) < EPS;",
			"    return abs(p.det(q)) < EPS && abs(r.det(s)) < EPS && abs(t.det(u)) < EPS;",
			"}",
			"",
			"// seg operations",
			"int sgn(const double &x)",
			"{",
			"    return x >= 0 ? x ? 1 : 0 : -1;",
			"}",
			"",
			"bool inter1(double a, double b, double c, double d)",
			"{",
			"    if (a > b)",
			"        swap(a, b);",
			"    if (c > d)",
			"        swap(c, d);",
			"    return max(a, c) <= min(b, d);",
			"}",
			"",
			"bool check_inter(const point2d &a, const point2d &b, const point2d &c, const point2d &d)",
			"{",
			"    if (c.cross(a, d) == 0 && c.cross(b, d) == 0)",
			"        return inter1(a.x, b.x, c.x, d.x) && inter1(a.y, b.y, c.y, d.y);",
			"    return sgn(a.cross(b, c)) != sgn(a.cross(b, d)) &&",
			"           sgn(c.cross(d, a)) != sgn(c.cross(d, b));",
			"}",
			"",
			"// Oriented area of a triangle",
			"double signed_area_parallelogram(point2d a, point2d b, point2d c)",
			"{",
			"    return (b - a).cross(c - b);",
			"}",
			"",
			"double triangle_area(point2d a, point2d b, point2d c)",
			"{",
			"    return abs(signed_area_parallelogram(a, b, c)) / 2;",
			"}",
			"",
			"bool clockwise(point2d a, point2d b, point2d c)",
			"{",
			"    return signed_area_parallelogram(a, b, c) < 0;",
			"}",
			"",
			"bool counter_clockwise(point2d a, point2d b, point2d c)",
			"{",
			"    return signed_area_parallelogram(a, b, c) > 0;",
			"}",
			"",
			"// polygone area",
			"",
			"double area(const vector<point2d> &p)",
			"{",
			"    double res = 0;",
			"    for (int i = 0; i < p.size(); i++)",
			"    {",
			"        int j = (i + 1) % p.size();",
			"        res += p[i].cross(p[j]);",
			"    }",
			"    return fabs(res) / 2;",
			"}"
		],
		"description": "geo"
	},
	"pointinconvex": {
		"prefix": "pointinconvex",
		"body": [
			"bool pointInTriangle(point2d a, point2d b, point2d c, point2d p)",
			"{",
			"    int s1 = abs(a.cross(b, c));",
			"    int s2 = abs(p.cross(a, b)) + abs(p.cross(b, c)) + abs(p.cross(c, a));",
			"    return s1 == s2;",
			"}",
			"",
			"bool lexComp(point2d a, point2d b)",
			"{",
			"    return a.x < b.x || (a.x == b.x && a.y < b.y);",
			"}",
			"",
			"void prepare(vector<point2d> &points, vector<point2d> &seq, int &n, point2d &pivot)",
			"{",
			"    n = points.size();",
			"    int pos = 0;",
			"    for (int i = 0; i < n; i++)",
			"    {",
			"        if (lexComp(points[i], points[pos]))",
			"            pos = i;",
			"    }",
			"    rotate(points.begin(), points.begin() + pos, points.end());",
			"",
			"    n--;",
			"    seq.resize(n);",
			"    for (int i = 0; i < n; i++)",
			"    {",
			"        seq[i] = points[i + 1] - points[0];",
			"    }",
			"    pivot = points[0];",
			"}",
			"",
			"bool pointInConvexPolygon(point2d point, vector<point2d> &seq, int n, point2d pivot)",
			"{",
			"    point = point - pivot;",
			"    if (seq[0].cross(point) != 0 && sgn(seq[0].cross(point)) != sgn(seq[0].cross(seq.back())))",
			"        return false;",
			"    if (seq.back().cross(point) != 0 && sgn(seq.back().cross(point)) != sgn(seq.back().cross(seq[0])))",
			"        return false;",
			"    if (seq[0].cross(point) == 0)",
			"    {",
			"        return seq[0].norm() >= point.norm();",
			"    }",
			"",
			"    int l = 0, r = n - 1;",
			"    while (r - l > 1)",
			"    {",
			"        int mid = (l + r) / 2;",
			"        int pos = mid;",
			"        if (seq[pos].cross(point) >= 0)",
			"        {",
			"            l = mid;",
			"        }",
			"        else",
			"        {",
			"            r = mid;",
			"        }",
			"    }",
			"    int pos = l;",
			"    return pointInTriangle(seq[pos], seq[pos + 1], point2d(0, 0), point);",
			"}"
		],
		"description": "pointinconvex"
	},
	"LCA": {
		"prefix": "LCA",
		"body": [
			"const int N = 1e5, M = 20;",
			"vector<int> gr[N];",
			"vector<int> dep(N, 0);",
			"vector<vector<int>> Par(N, vector<int>(M));",
			"",
			"void dfs(int cur, int par)",
			"{",
			"    dep[cur] = dep[par] + 1;",
			"    Par[cur][0] = par;",
			"    for (int j = 1; j < M; j++)",
			"    {",
			"        Par[cur][j] = Par[Par[cur][j - 1]][j - 1];",
			"    }",
			"",
			"    for (auto x : gr[cur])",
			"    {",
			"        if (x != par)",
			"        {",
			"            dfs(x, cur);",
			"        }",
			"    }",
			"}",
			"int LCA(int u, int v)",
			"{",
			"    if (u == v)",
			"        return u;",
			"    if (dep[u] < dep[v])",
			"        swap(u, v);",
			"",
			"    int diff = dep[u] - dep[v];",
			"    for (int i = M - 1; i >= 0; i--)",
			"    {",
			"        if ((diff >> i) & 1)",
			"        {",
			"            u = Par[u][i];",
			"        }",
			"    }",
			"",
			"    for (int i = M - 1; i >= 0; i--)",
			"    {",
			"        if (Par[u][i] != Par[v][i])",
			"        {",
			"            u = Par[u][i];",
			"            v = Par[v][i];",
			"        }",
			"    }",
			"",
			"    return Par[u][0];",
			"    return 0;",
			"}"
		],
	},
	"Lucas": {
		"prefix": "Lucas",
		"body": [
			"//remember that the modulo should be prime",
			"//you can change the method of calculatiin the nCr",
			"int power(int a, int b, int modulo)",
			"{",
			"    int res = 1;",
			"    while (b)",
			"    {",
			"        if (b & 1)",
			"            res = (res * a) % modulo;",
			"        a = (a * a) % modulo;",
			"        b >>= 1;",
			"    }",
			"    return res;",
			"}",
			"",
			"int modinv(int a, int m)",
			"{",
			"    return power(a, m - 2, m);",
			"}",
			"",
			"int nCr(int n, int r, int modulo)",
			"{",
			"    if (r > n)",
			"    {",
			"        return 0;",
			"    }",
			"    if (r == 0)",
			"    {",
			"        return 1;",
			"    }",
			"    int res = 1;",
			"    for (int i = 1; i <= r; i++)",
			"    {",
			"        res = (res * (n - i + 1)) % modulo;",
			"        res = (res * modinv(i, modulo)) % modulo;",
			"    }",
			"    return res;",
			"}",
			"",
			"int Lucas(int n, int r, int modulo)",
			"{",
			"    if (r == 0)",
			"        return 1;",
			"    return (Lucas(n / modulo, r / modulo, modulo) * nCr(n % modulo, r % modulo, modulo)) % modulo;",
			"}"
		],
		"description": "Lucas"
	},
	"topologicalsort": {
		"prefix": "topologicalsort",
		"body": [
			"const int N = 1e5 + 1;\r",
			"\r",
			"vector<int> gr[N];\r",
			"vector<int> order;\r",
			"int vis[N];\r",
			"\r",
			"void dfs(int cur, int par)\r",
			"{\r",
			"  vis[cur] = 1;\r",
			"  for (auto x : gr[cur])\r",
			"  {\r",
			"    if (!vis[x])\r",
			"    {\r",
			"      dfs(x, cur);\r",
			"    }\r",
			"  }\r",
			"  // I am here because I came back from the subtree\r",
			"  order.push_back(cur);\r",
			"  return;\r",
			"}"
		],
		"description": "topologicalsort"
	},
	"segtree": {
		"prefix": "segtree",
		"body": [
			"struct segmenttree\r",
			"{\r",
			"  int IDENT = 0;\r",
			"  int n;\r",
			"  vector<int> st;\r",
			"  void init(int _n)\r",
			"  {\r",
			"    this->n = _n;\r",
			"    st.resize(4 * n, IDENT);\r",
			"  }\r",
			"\r",
			"  void build(int start, int ending, int node, vector<int> &v)\r",
			"  {\r",
			"    if (start == ending)\r",
			"    {\r",
			"      st[node] = v[start];\r",
			"      return;\r",
			"    }\r",
			"\r",
			"    int mid = (start + ending) / 2;\r",
			"    build(start, mid, 2 * node + 1, v);\r",
			"    build(mid + 1, ending, 2 * node + 2, v);\r",
			"    st[node] = combine(st[2 * node + 1], st[2 * node + 2]);\r",
			"  }\r",
			"  void build(vector<int> &v)\r",
			"  {\r",
			"    build(0, v.size() - 1, 0, v);\r",
			"  }\r",
			"\r",
			"  int query(int start, int ending, int l, int r, int node)\r",
			"  {\r",
			"    if (start > r || ending < l)\r",
			"    {\r",
			"      return IDENT;\r",
			"    }\r",
			"    if (start >= l && ending <= r)\r",
			"    {\r",
			"      return st[node];\r",
			"    }\r",
			"    int mid = (start + ending) / 2;\r",
			"    int q1 = query(start, mid, l, r, 2 * node + 1);\r",
			"    int q2 = query(mid + 1, ending, l, r, 2 * node + 2);\r",
			"    return combine(q1, q2);\r",
			"  }\r",
			"\r",
			"  int query(int l, int r)\r",
			"  {\r",
			"    return query(0, n - 1, l, r, 0);\r",
			"  }\r",
			"\r",
			"  void update(int start, int ending, int node, int index, int value)\r",
			"  {\r",
			"    if (start == ending)\r",
			"    {\r",
			"      st[node] = value;\r",
			"      return;\r",
			"    }\r",
			"\r",
			"    int mid = (start + ending) / 2;\r",
			"    if (index <= mid)\r",
			"    {\r",
			"      update(start, mid, 2 * node + 1, index, value);\r",
			"    }\r",
			"    else\r",
			"    {\r",
			"      update(mid + 1, ending, 2 * node + 2, index, value);\r",
			"    }\r",
			"\r",
			"    st[node] = combine(st[2 * node + 1], st[2 * node + 2]);\r",
			"  }\r",
			"\r",
			"  int combine(int a, int b)\r",
			"  {\r",
			"    return a ^ b;\r",
			"  }\r",
			"\r",
			"  void update(int index, int value)\r",
			"  {\r",
			"    update(0, n - 1, 0, index, value);\r",
			"  }\r",
			"} tree;"
		],
		"description": "segtree"
	},
	"lazysegtree": {
		"prefix": "lazysegtree",
		"body": [
			"struct segmenttree\r",
			"{\r",
			"  int IDENT = 0;\r",
			"  int n;\r",
			"  vector<int> st, lazy;\r",
			"  void init(int _n)\r",
			"  {\r",
			"    this->n = _n;\r",
			"    st.resize(4 * n, IDENT);\r",
			"    lazy.resize(4 * n, IDENT);\r",
			"  }\r",
			"\r",
			"  void build(int start, int ending, int node, vector<int> &v)\r",
			"  {\r",
			"    if (start == ending)\r",
			"    {\r",
			"      st[node] = v[start];\r",
			"      return;\r",
			"    }\r",
			"\r",
			"    int mid = (start + ending) / 2;\r",
			"    build(start, mid, 2 * node + 1, v);\r",
			"    build(mid + 1, ending, 2 * node + 2, v);\r",
			"    st[node] = combine(st[2 * node + 1], st[2 * node + 2]);\r",
			"  }\r",
			"  void build(vector<int> &v)\r",
			"  {\r",
			"    build(0, v.size() - 1, 0, v);\r",
			"  }\r",
			"\r",
			"  int query(int start, int ending, int l, int r, int node)\r",
			"  {\r",
			"    if (start > r || ending < l)\r",
			"    {\r",
			"      return IDENT;\r",
			"    }\r",
			"    if (lazy[node] != IDENT)\r",
			"    {\r",
			"      // pending updates\r",
			"      st[node] += lazy[node] * (ending - start + 1);\r",
			"      if (start != ending)\r",
			"      {\r",
			"        lazy[2 * node + 1] += lazy[node];\r",
			"        lazy[2 * node + 2] += lazy[node];\r",
			"      }\r",
			"      lazy[node] = IDENT;\r",
			"    }\r",
			"\r",
			"    if (start >= l && ending <= r)\r",
			"    {\r",
			"      return st[node];\r",
			"    }\r",
			"    int mid = (start + ending) / 2;\r",
			"    int q1 = query(start, mid, l, r, 2 * node + 1);\r",
			"    int q2 = query(mid + 1, ending, l, r, 2 * node + 2);\r",
			"    return combine(q1, q2);\r",
			"  }\r",
			"\r",
			"  int query(int l, int r)\r",
			"  {\r",
			"    return query(0, n - 1, l, r, 0);\r",
			"  }\r",
			"\r",
			"  void update(int start, int ending, int node, int l, int r, int value)\r",
			"  {\r",
			"    if (start > r || ending < l)\r",
			"    {\r",
			"      return;\r",
			"    }\r",
			"    if (lazy[node] != IDENT)\r",
			"    {\r",
			"      st[node] += lazy[node] * (ending - start + 1);\r",
			"      if (start != ending)\r",
			"      {\r",
			"        lazy[2 * node + 1] += lazy[node];\r",
			"        lazy[2 * node + 2] += lazy[node];\r",
			"      }\r",
			"      lazy[node] = IDENT;\r",
			"    }\r",
			"    if (start >= l && ending <= r)\r",
			"    {\r",
			"      st[node] += value * (ending - start + 1);\r",
			"      if (start != ending)\r",
			"      {\r",
			"        lazy[2 * node + 1] += value;\r",
			"        lazy[2 * node + 2] += value;\r",
			"      }\r",
			"      return;\r",
			"    }\r",
			"    int mid = (start + ending) / 2;\r",
			"    update(start, mid, 2 * node + 1, l, r, value);\r",
			"    update(mid + 1, ending, 2 * node + 2, l, r, value);\r",
			"    st[node] = combine(st[2 * node + 1], st[2 * node + 2]);\r",
			"  }\r",
			"\r",
			"  void update(int l, int r, int x)\r",
			"  {\r",
			"    update(0, n - 1, 0, l, r, x);\r",
			"  }\r",
			"  int combine(int a, int b)\r",
			"  {\r",
			"    return a + b;\r",
			"  }\r",
			"} tree;"
		],
		"description": "lazysegtree"
	},
	"matrix": {
		"prefix": "matrix",
		"body": [
			"class Mat",
			"{",
			"public:",
			"    int n, m;",
			"    vector<vector<int>> mat;",
			"    Mat(int n, int m)",
			"    {",
			"        this->n = n;",
			"        this->m = m;",
			"        mat.resize(n, vector<int>(m, 0));",
			"    }",
			"    void identity()",
			"    {",
			"        for (int i = 0; i < n; i++)",
			"        {",
			"            mat[i][i] = 1;",
			"        }",
			"    }",
			"",
			"    void print()",
			"    {",
			"        cout << \"Matrix \" << n << \" * \" << m << \"\\n\";",
			"        for (int i = 0; i < n; i++)",
			"        {",
			"            for (int j = 0; j < m; j++)",
			"            {",
			"                cout << mat[i][j] << \" \";",
			"            }",
			"            cout << \"\\n\";",
			"        }",
			"    }",
			"",
			"    Mat operator*(const Mat &other)",
			"    {",
			"        Mat res(n, other.m);",
			"        for (int i = 0; i < n; i++)",
			"        {",
			"            for (int j = 0; j < other.m; j++)",
			"            {",
			"                for (int k = 0; k < m; k++)",
			"                {",
			"                    res.mat[i][j] = (res.mat[i][j] + ((mat[i][k] * other.mat[k][j]) % mod) + mod) % mod;",
			"                }",
			"            }",
			"        }",
			"        return res;",
			"    }",
			"    Mat operator^(int b)",
			"    {",
			"        Mat res(n, m);",
			"        res.identity();",
			"        Mat a = *this;",
			"        while (b > 0)",
			"        {",
			"            if (b & 1)",
			"                res = res * a;",
			"            a = a * a;",
			"            b >>= 1;",
			"        }",
			"        return res;",
			"    }",
			"};"
		],
		"description": "matrix"
	},
	"segtreevertex": {
		"prefix": "segtreevertex",
		"body": [
			"struct Node",
			"{",
			"    int prefix;",
			"    int suffix;",
			"    int sum;",
			"    int mx;",
			"",
			"    Node(int value)",
			"    {",
			"        prefix = max(value, 0ll);",
			"        suffix = max(value, 0ll);",
			"        mx = max(value, 0ll);",
			"        sum = value;",
			"    }",
			"",
			"    Node(Node left, Node right)",
			"    {",
			"        sum = left.sum + right.sum;",
			"        prefix = max(left.prefix, left.sum + right.prefix);",
			"        suffix = max(right.suffix, right.sum + left.suffix);",
			"        mx = max({left.mx, right.mx, left.suffix + right.prefix});",
			"    }",
			"};",
			"",
			"struct segmenttree",
			"{",
			"    Node IDENT = Node(0);",
			"    int n;",
			"    vector<Node> st;",
			"    void init(int _n)",
			"    {",
			"        this->n = _n;",
			"        st.resize(4 * n, IDENT);",
			"    }",
			"",
			"    void build(int start, int ending, int node, vector<int> &v)",
			"    {",
			"        if (start == ending)",
			"        {",
			"            st[node] = Node(v[start]);",
			"",
			"            return;",
			"        }",
			"        int mid = (start + ending) / 2;",
			"        build(start, mid, 2 * node + 1, v);",
			"        build(mid + 1, ending, 2 * node + 2, v);",
			"        st[node] = Node(st[2 * node + 1], st[2 * node + 2]);",
			"    }",
			"    void build(vector<int> &v)",
			"    {",
			"        build(0, v.size() - 1, 0, v);",
			"    }",
			"",
			"    Node query(int start, int ending, int l, int r, int node)",
			"    {",
			"        if (start > r || ending < l)",
			"        {",
			"            return IDENT;",
			"        }",
			"        if (start >= l && ending <= r)",
			"            return st[node];",
			"        int mid = (start + ending) / 2;",
			"        Node left = query(start, mid, l, r, 2 * node + 1);",
			"        Node right = query(mid + 1, ending, l, r, 2 * node + 2);",
			"        Node res = Node(left, right);",
			"        return res;",
			"    }",
			"",
			"    int query(int l, int r)",
			"    {",
			"        Node res = query(0, n - 1, l, r, 0);",
			"        return res.mx;",
			"    }",
			"",
			"    void update(int start, int ending, int node, int index, int value)",
			"    {",
			"",
			"        if (start > index || ending < index)",
			"            return;",
			"        if (start == index && ending == index)",
			"        {",
			"            st[node] = Node(value);",
			"            return;",
			"        }",
			"        int mid = (start + ending) / 2;",
			"        update(start, mid, 2 * node + 1, index, value);",
			"        update(mid + 1, ending, 2 * node + 2, index, value);",
			"        st[node] = Node(st[2 * node + 1], st[2 * node + 2]);",
			"    }",
			"",
			"    int combine(int a, int b)",
			"    {",
			"        return a + b;",
			"    }",
			"",
			"    void update(int index, int value)",
			"    {",
			"        update(0, n - 1, 0, index, value);",
			"    }",
			"} tree;"
		],
		"description": "segtreevertex"
	}
}
