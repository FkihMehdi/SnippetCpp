//prepare snippets for c++
{
	"solve":{
		"prefix": "solve",
		"body": [
			"#include <bits/stdc++.h>",
			"#define ll long long",
			"#define ld long double",
			"#define pb push_back",
			"#define mp make_pair",
			"#define pii pair<int,int>",
			"#define pll pair<ll,ll>",
			"#define vi vector<int>",
			"#define vll vector<ll>",
			"#define vvi vector<vi>",
			"#define vvl vector<vll>",
			"#define vpii vector<pii>",
			"#define vpll vector<pll>",
			"#define rep(i,a,b) for(int i=a;i<b;i++)",
			"#define all(a) a.begin(),a.end()",
			"#define fi first",
			"#define se second",
			"#define sz(a) (int)(a.size())",
			"#define ms(s,val) memset(s,val,sizeof(s))",
			"#define inf 1000000000",
			"#define mod 1000000007",
			"#define pi 3.14159265358979323846",
			"#define repd(i,a,b) for(int i=a;i>=b;i--)",
			"#define endl '\\n'",
			"#define bits(x) __builtin_popcount(x)",
			"#define len(a) ((int)(a).size())",
			"using namespace std;",
			"void yes(){cout<<\"YES\\n\";}",
			"void no(){cout<<\"NO\\n\";}",
			"void solve(){",
			"",
			"}",

			"int main(){",
			"ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);",
			"#ifndef ONLINE_JUDGE",
			"freopen(\"input.txt\",\"r\",stdin);",
			"freopen(\"output.txt\",\"w\",stdout);",
			"#endif",
			"int t;cin>>t;",
			"while(t--){",
		  "     solve();",
			"}",
			"return 0;",
			"}",
		],
		"description": "solve"
	},
	"diophantine":{
		"prefix" : "diophantine",
		"body" : [
			"ll gcd(ll a,ll b,ll &x,ll &y){",
			"if(b==0){",
			"x=1,y=0;",
			"return a;",
			"}",
			"ll x1,y1;",
			"ll g=gcd(b,a%b,x1,y1);",
			"x=y1,y=x1-(a/b)*y1;",
			"return g;",
			"}",
			"bool find_any_solution(ll a,ll b,ll c,ll &x0,ll &y0,ll &g){",
			"g=gcd(abs(a),abs(b),x0,y0);",
			"if(c%g){",
			"return false;",
			"}",
			"x0*=c/g,y0*=c/g;",
			"if(a<0)x0=-x0;",
			"if(b<0)y0=-y0;",
			"return true;",
			"}",
		]
	},
	"totientloglog":{
		"prefix" : "totientloglog",
		"body" : [
			"// phi in O(nloglogn)",
			"const int N = 1e6 + 5;",
			"ll phi[N + 2];",
			"void computeTotient()",
			"{",
				"for (int i = 0; i <= N; i++)",
					"    phi[i] = i;",
			
				"for (int i = 2; i <= N; i++)",
				"{",
					"    if (phi[i] == i)",
					"    {",
						"     for (int j = i; j <= N; j += i)",
							"      phi[j] -= phi[j] / i;",
					"}",
				"}",
			"}",
		]
	},
	"totientsqrt":{
		"prefix" : "totientsqrt",
		"body" : [
			"// phi in O(sqrt(n))",
			"ll phi(ll n)",
			"{",
				"ll result = n;",
				"for (ll p = 2; p * p <= n; ++p) {",
					"if (n % p == 0) {",
						"while (n % p == 0)",
							"n /= p;",
						"result -= result / p;",
					"}",
				"}",
				"if (n > 1)",
					"result -= result / n;",
				"return result;",
			"}",
		]
	},
	"seive":
	{
		"prefix" : "seive",
		"body" : [
			"const int N = 1e6 + 5;",
			"bool prime[N + 2];",
			"void seive()",
			"{",
				"memset(prime, true, sizeof(prime));",
				"prime[0] = prime[1] = false;",
				"for (int i = 2; i <= N; i++)",
				"{",
					"if (prime[i])",
					"{",
						"for (int j = i * i; j <= N; j += i)",
							"prime[j] = false;",
					"}",
				"}",
			"}",
		]
	},
	"inverse":
	{
		"prefix" : "inverse",
		"body" : [
			"// inverse modulo",
			"ll gcd(ll a, ll b, ll &x, ll &y)",
			"{",
				"if (b == 0)",
				"{",
					"x = 1, y = 0;",
					"return a;",
				"}",
				"ll x1, y1;",
				"ll g = gcd(b, a % b, x1, y1);",
				"x = y1;",
				"y = x1 - (a / b) * y1;",
				"return g;",
			"}",
			"ll inverse(ll a, ll m)",
			"{",
				"ll x, y;",
				"ll g = gcd(a, m, x, y);",
				"if (g != 1)",
					"return -1;",
				"else",
				"{",
					"x = (x % m + m) % m;",
					"return x;",
				"}",
			"}",
			
		]
	},
	"chiense":
	{
		"prefix" : "chiense",
		"body" : [
			"//chieense remainder theorem",
			"struct Congruence",
			"{",
			"ll a, n;",
			"};",
			"ll chinese_remainder(vector<Congruence> &congruences)",
			"{",
			"ll prod = 1;",
			"for (auto &c : congruences)",
			"prod *= c.n;",
			"ll result = 0;",
			"for (auto &c : congruences)",
			"{",
			"ll m = prod / c.n;",
			"ll mi = inverse(m, c.n);",
			"result = (result + c.a * m * mi) % prod;",
			"}",
			"return result;",
			"}",
		]
	},
	"numberofdivisor" : 
	{
		"prefix" : "numberofdivisor",
		"body" : [
			"// number of divisor",
			"ll number_of_divisor(ll n)",
			"{",
			"ll result = 1;",
			"for (ll p = 2; p * p <= n; ++p)",
			"{",
			"ll cnt = 0;",
			"while (n % p == 0)",
			"{",
			"n /= p;",
			"cnt++;",
			"}",
			"result *= (cnt + 1);",
			"}",
			"if (n > 1)",
			"result *= 2;",
			"return result;",
			"}",
		]
	},
	"sumrofdivisor": 
	{
		"prefix" : "sumrofdivisor",
		"body" : [
			"ll power(ll a, ll b)",
			"{",
			"ll result = 1;",
			"while (b > 0)",
			"{",
			"if (b & 1)",
			"result = result * a;",
			"a = a * a;",
			"b >>= 1;",
			"}",
			"return result;",
			"}",

			"// sum of divisor",
			"ll sum_of_divisor(ll n)",
			"{",
			"ll result = 1;",
			"for (ll p = 2; p * p <= n; ++p)",
			"{",
			"ll cnt = 0;",
			"while (n % p == 0)",
			"{",
			"n /= p;",
			"cnt++;",
			"}",
			"result *= ((power(p, cnt + 1) - 1) / (p - 1));",
			"}",
			"if (n > 1)",
			"result *= (n+1);",
			"return result;",
			"}",
		]
	},
	"power":{
		"prefix" : "power",
		"body" : [
			"ll power(ll a, ll b)",
			"{",
			"ll result = 1;",
			"while (b > 0)",
			"{",
			"if (b & 1)",
			"result = (result * a) % mod;",
			"a = (a * a) % mod;",
			"b >>= 1;",
			"}",
			"return result;",
			"}",
		]
	},
	"nCr":{
		"prefix" : "nCr",
		"body" : [
			"ll fact[N], invfact[N];",
			"void precompute()",
			"{",
			"fact[0] = 1;",
			"for (int i = 1; i < N; i++)",
			"fact[i] = (fact[i - 1] * i) % mod;",
			"invfact[N - 1] = power(fact[N - 1], mod - 2);",
			"for (int i = N - 2; i >= 0; i--)",
			"invfact[i] = (invfact[i + 1] * (i + 1)) % mod;",
			"}",
			"ll nCr(ll n, ll r)",
			"{",
			"if (r > n)",
			"return 0;",
			"ll ans = (fact[n] * invfact[r]) % mod;",
			"ans = (ans * invfact[n - r]) % mod;",
			"return ans;",
			"}",
		]
	},
	"Mobius":
	{
		"prefix": "Mobius",
		"body": [
			"// mobius function",
			"const int N = 1e6 + 5;",
			"vector<int> mobius(N + 2, 1);",
			"void Mobius()",
			"{",
			"for(int i = 1; i <= N; i++){",
			"if (i == 1) mobius[i] = 1;",
			"else{",
			"if (prime[i/prime[i]] == prime[i]) mobius[i] = 0;",
			"else mobius[i] = -mobius[i/prime[i]];",
			"}",
			"}",
			"}",
		]
	}
 }
